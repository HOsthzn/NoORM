As software developers, Object-Relational Mapping (ORM) tools like Entity Framework have become an essential tool for simplifying the process of working with databases. These tools allow us to interact with data using object-oriented constructs instead of writing raw SQL. However, there are certain situations where using an ORM may not be feasible or the best option.

One of the most common scenarios where ORMs may not be practical is when working with legacy systems. If the existing system was built without an ORM, retrofitting it with one can be a significant undertaking that requires a lot of time and effort. In these cases, it may be more feasible to continue using raw SQL or another database access method.

Performance is another factor to consider. ORMs can introduce performance bottlenecks when working with large datasets, especially if the ORM generates suboptimal SQL. In these cases, writing raw SQL can provide better performance and may be a more appropriate solution.

Custom database engines can also pose a challenge for ORMs. If the database engine you are working with is not supported by popular ORMs, it may not be possible to use an ORM with that database. In these situations, raw SQL or another database access method may need to be used.

Security is a critical concern in many industries, particularly in the financial and medical sectors. There may be concerns about the security of the data being transmitted between the database and the ORM. In these cases, using raw SQL or another database access method may be necessary to ensure the security of sensitive data.

Finally, there may be instances where custom business logic requires more control over the underlying SQL generated by the ORM. In these cases, it may not be feasible to implement the required logic using an ORM, and raw SQL or another database access method may need to be used.

In conclusion, while ORMs like Entity Framework can simplify the process of working with databases, there are certain situations where they may not be the best option. Whether due to legacy systems, performance concerns, custom database engines, security concerns, or custom business logic, having a raw SQL option as a backup solution can provide numerous benefits.

___

## AdoNet Class Usage Examples

The AdoNet class provides several functions to execute SQL commands, retrieve results and manipulate data in a database using ADO.NET. Here's an example of how to use the different functions of the AdoNet class.

### ExecuteCommand
This method executes a non-query command, such as an INSERT, UPDATE, or DELETE statement, against a database and returns the number of rows affected and the parameters used during the execution.
```csharp
string connectionString = "Data Source=(local);Initial Catalog=TestDB;Integrated Security=True";
AdoNet adoNet = new AdoNet(connectionString);

SqlParameter[] parameters = 
{
    new SqlParameter("@firstName", "John"),
    new SqlParameter("@lastName", "Doe")
};

var result = adoNet.ExecuteCommand("INSERT INTO dbo.Employees (FirstName, LastName) VALUES (@firstName, @lastName)",
    CommandType.Text, parameters);

Console.WriteLine("Number of rows affected: " + result.rowsAffected);
```

### ExecuteCommandAsync
This method is the asynchronous version of ExecuteCommand. It executes a non-query command asynchronously and returns the number of rows affected and the parameters used during the execution.
```csharp
string connectionString = "Data Source=(local);Initial Catalog=TestDB;Integrated Security=True";
AdoNet adoNet = new AdoNet(connectionString);

SqlParameter[] parameters = 
{
    new SqlParameter("@firstName", "John"),
    new SqlParameter("@lastName", "Doe")
};

var result = await adoNet.ExecuteCommandAsync("INSERT INTO dbo.Employees (FirstName, LastName) VALUES (@firstName, @lastName)",
    CommandType.Text, parameters);

Console.WriteLine("Number of rows affected: " + result.rowsAffected);
```

### ExecuteCommandDataSet
This method executes a command and returns the results in a DataSet.
```csharp
string connectionString = "Data Source=(local);Initial Catalog=TestDB;Integrated Security=True";
AdoNet adoNet = new AdoNet(connectionString);

var result = adoNet.ExecuteCommandDataSet("SELECT * FROM dbo.Employees", CommandType.Text);

foreach (DataRow row in result.Tables[0].Rows)
{
    Console.WriteLine("First Name: " + row["FirstName"] + ", Last Name: " + row["LastName"]);
}
```

### ExecuteScalar
ExecuteScalar is used to execute a command that returns a single value as a result. The function returns an object that can be cast to the appropriate data type.
```csharp
string connectionString = "Your connection string here";
AdoNet adoNet = new AdoNet(connectionString);

string commandText = "SELECT COUNT(*) FROM dbo.TableName";
CommandType commandType = CommandType.Text;

object result = adoNet.ExecuteScalar(commandText, commandType);

int count = (int) result;
Console.WriteLine("Number of rows in TableName: " + count);
```

### ExecuteScalarAsync
This example is similar to the previous example, but uses the asynchronous version of the ExecuteScalar function. The function returns a Task<object>.
```csharp
string connectionString = "Your connection string here";
AdoNet adoNet = new AdoNet(connectionString);

string commandText = "SELECT COUNT(*) FROM dbo.TableName";
CommandType commandType = CommandType.Text;

object result = await adoNet.ExecuteScalarAsync(commandText, commandType);

int count = (int) result;
Console.WriteLine("Number of rows in TableName: " + count);
```

### ExecuteReader
ExecuteReader is used to execute a query and map the results to a list of objects.
```csharp
List<User> users = adoNet.ExecuteReader<User>("SELECT * FROM Users", CommandType.Text);
```

Executing a stored procedure and mapping the results to a list of objects
```csharp
List<User> users = adoNet.ExecuteReader<User>("GetUsers", CommandType.StoredProcedure);
```

OR, Executing a stored procedure with parameters and mapping the results to a list of objects
```csharp
SqlParameter[] parameters = new[]
{
    new SqlParameter("@city", "London"),
};

List<User> users = adoNet.ExecuteReader<User>("GetUsersByCity", CommandType.StoredProcedure, parameters);
```

### ExecuteReaderAsync
This example is similar to the previous example, but uses the asynchronous version of the ExecuteReaderAsync function,
```csharp
List<User> users = await adoNet.ExecuteReaderAsync<User>("SELECT * FROM Users", CommandType.Text);
```

```csharp
List<User> users = await adoNet.ExecuteReaderAsync<User>("GetUsers", CommandType.StoredProcedure);
```

```csharp
SqlParameter[] parameters = new[]
{
    new SqlParameter("@city", "London"),
};

List<User> users = await adoNet.ExecuteReaderAsync<User>("GetUsersByCity", CommandType.StoredProcedure, parameters);
```
